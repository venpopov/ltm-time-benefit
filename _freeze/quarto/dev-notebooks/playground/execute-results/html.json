{
  "hash": "249c3646e79197a05fdbfba9a57efaf1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Playground\"\nformat: html\n---\n\n\n## Contraint/Unconstrain vectorizing tests\n\nI want to build a constrain/unconstrain function. Here' are two versions. The second one is vectorized\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"R/utils.R\")\n\nconstrain <- function(x, lb, ub) {\n  if (is.infinite(lb) && is.infinite(ub)) {\n    x\n  } else if (is.infinite(ub)) {\n    exp(x) + lb\n  } else if (is.infinite(lb)) {\n    ub - exp(x)\n  } else {\n    inv_logit(x, lb = lb, ub = ub)\n  }\n}\n\nconstrain_vec <- function(x, lb, ub) {\n  ifelse(is.infinite(lb) & is.infinite(ub), x,\n    ifelse(is.infinite(ub), exp(x) + lb,\n      ifelse(is.infinite(lb), ub - exp(x),\n        inv_logit(x, lb = lb, ub = ub)\n      )\n    )\n  )\n}\n\nconstrain_vec2 <- function(x, lb, ub) {\n  if (length(lb) == 1 && length(ub) == 1 && is.infinite(lb) && is.infinite(ub)) {\n    return(x)\n  }\n\n  dplyr::case_when(\n    is.infinite(lb) & is.infinite(ub) ~ x,\n    is.infinite(ub) ~ exp(x) + lb,\n    is.infinite(lb) ~ ub - exp(x),\n    .default = inv_logit(x, lb = lb, ub = ub)\n  )\n}\n```\n:::\n\n\nLet's test them\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nlibrary(microbenchmark)\nN <- 1000\nx <- c(log(rexp(N)), logit(runif(N)), rnorm(N))\nlb <- c(rep(0, N), rep(0, N), rep(-Inf, N))\nub <- c(rep(Inf, N), rep(1, N), rep(Inf, N))\n\nmicrobenchmark(\n  pmap_dbl(list(x, lb, ub), constrain),\n  constrain_vec(x, lb, ub),\n  constrain_vec2(x, lb, ub),\n  times = 100,\n  check = \"equivalent\"\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in microbenchmark(pmap_dbl(list(x, lb, ub), constrain), constrain_vec(x, : less accurate nanosecond times to\navoid potential integer overflows\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n                                 expr      min        lq      mean   median       uq      max neval\n pmap_dbl(list(x, lb, ub), constrain) 2713.872 2840.2545 3036.3792 2886.133 2988.203 4180.278   100\n             constrain_vec(x, lb, ub)  115.907  124.0045  164.7351  139.564  160.474 1943.236   100\n            constrain_vec2(x, lb, ub)  152.274  158.2600  198.5253  168.346  182.614 2451.185   100\n```\n\n\n:::\n:::\n\n\nYes, the vectorized version is much faster. But it's not as readable as the first one. The dplyr version is cleanest and just as fast.\n\nWhat about if the bounds were fixed?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(\n  (function(x) x)(x),\n  pmap_dbl(list(x, -Inf, Inf), constrain),\n  constrain_vec2(x, -Inf, Inf),\n  times = 100,\n  check = \"equivalent\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: nanoseconds\n                                    expr     min      lq       mean  median      uq     max neval\n                      (function(x) x)(x)      82     123     193.52     164     205    1804   100\n pmap_dbl(list(x, -Inf, Inf), constrain) 2308792 2351084 2481415.94 2377795 2478594 3738708   100\n            constrain_vec2(x, -Inf, Inf)     369     410     592.45     533     656    2255   100\n```\n\n\n:::\n:::\n\n\n## A better version of optim\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"R/utils.R\")\nfn <- function(par, x) {\n  tryCatch(\n    {\n      -sum(bmm::dmixture2p(x, mu = 0, kappa = par[1], pMem = par[2], log = TRUE))\n    },\n    error = function(e) NA\n  )\n}\nx <- bmm::rmixture2p(100)\n\nmicrobenchmark(\n  optim(c(5, 0.1), fn, x = x),\n  optim2(c(5, 0.1), fn, x = x, lower = c(0, 0), upper = c(Inf, 1)),\n  times = 100\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n                                                                  expr      min        lq      mean    median        uq\n                                           optim(c(5, 0.1), fn, x = x)  798.885  830.3935  889.3056  845.3995  878.1585\n optim2(c(5, 0.1), fn, x = x, lower = c(0, 0), upper = c(Inf,      1)) 6654.628 6892.8175 7369.2711 6980.6190 7252.5310\n       max neval\n  4345.016   100\n 18253.323   100\n```\n\n\n:::\n:::\n\n\nHow well does it work for different starting values?\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptim3 <- function(par, fn, ...) {\n  fn2 <- function(par, ...) {\n    par <- c(exp(par[1]), inv_logit(par[2]))\n    fn(par, ...)\n  }\n\n  start <- c(log(par[1]), logit(par[2]))\n  res <- optim(start, fn2, ..., control = list(parscale = c(1, 0.1)))\n  c(exp(res$par[1]), inv_logit(res$par[2]))\n}\n\nset.seed(123)\nx <- bmm::rmixture2p(100)\nstart <- as.matrix(expand.grid(\n  kappa = c(1, 5, 10),\n  pMem = c(0.6, 0.9, 0.99)\n))\n\nres <- apply(start, 1, optim3, fn = fn, x = x)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]      [,2]      [,3]     [,4]      [,5]      [,6]      [,7]      [,8]      [,9]\nkappa 4.7261620 4.7263468 4.7270363 4.725718 4.7286134 4.7273205 4.7257450 4.7265932 4.7260440\npMem  0.6122896 0.6123198 0.6122103 0.612269 0.6122014 0.6122376 0.6122722 0.6123254 0.6123247\n```\n\n\n:::\n\n```{.r .cell-code}\nmixtur::fit_mixtur(data.frame(response = x, target = 0, id = 1), model = \"2_component\", unit = \"radians\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nModel fit running. Please wait...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nModel fit finished.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id kappa   p_t   p_u\n1  1 4.726 0.612 0.388\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(\n  apply(start, 1, optim3, fn = fn, x = x),\n  apply(start, 1, optim2, fn = fn, x = x, lower = c(0, 0), upper = c(Inf, 1)),\n  times = 100\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n                                                                             expr      min       lq     mean   median\n                                          apply(start, 1, optim3, fn = fn, x = x) 13.21332 13.66803 15.41347 13.83096\n apply(start, 1, optim2, fn = fn, x = x, lower = c(0, 0), upper = c(Inf,      1)) 71.12873 74.38698 75.99708 75.52971\n       uq       max neval\n 14.39625 116.75103   100\n 77.44814  87.57005   100\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}