{
  "hash": "249c3646e79197a05fdbfba9a57efaf1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Playground\"\nformat: html\n---\n\n\n## Contraint/Unconstrain vectorizing tests\n\nI want to build a constrain/unconstrain function. Here' are two versions. The second one is vectorized\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"R/utils.R\")\n\nconstrain <- function(x, lb, ub) {\n  if (is.infinite(lb) && is.infinite(ub)) {\n    x\n  } else if (is.infinite(ub)) {\n    exp(x) + lb\n  } else if (is.infinite(lb)) {\n    ub - exp(x)\n  } else {\n    inv_logit(x, lb = lb, ub = ub)\n  }\n}\n\nconstrain_vec <- function(x, lb, ub) {\n  ifelse(is.infinite(lb) & is.infinite(ub), x,\n    ifelse(is.infinite(ub), exp(x) + lb,\n      ifelse(is.infinite(lb), ub - exp(x),\n        inv_logit(x, lb = lb, ub = ub)\n      )\n    )\n  )\n}\n\nconstrain_vec2 <- function(x, lb, ub) {\n  if (length(lb) == 1 && length(ub) == 1 && is.infinite(lb) && is.infinite(ub)) {\n    return(x)\n  }\n\n  dplyr::case_when(\n    is.infinite(lb) & is.infinite(ub) ~ x,\n    is.infinite(ub) ~ exp(x) + lb,\n    is.infinite(lb) ~ ub - exp(x),\n    .default = inv_logit(x, lb = lb, ub = ub)\n  )\n}\n```\n:::\n\n\nLet's test them\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nlibrary(microbenchmark)\nN <- 1000\nx <- c(log(rexp(N)), logit(runif(N)), rnorm(N))\nlb <- c(rep(0, N), rep(0, N), rep(-Inf, N))\nub <- c(rep(Inf, N), rep(1, N), rep(Inf, N))\n\nmicrobenchmark(\n  pmap_dbl(list(x, lb, ub), constrain),\n  constrain_vec(x, lb, ub),\n  constrain_vec2(x, lb, ub),\n  times = 100,\n  check = \"equivalent\"\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in microbenchmark(pmap_dbl(list(x, lb, ub), constrain), constrain_vec(x, : less accurate nanosecond times to\navoid potential integer overflows\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n                                 expr      min        lq      mean    median        uq       max neval\n pmap_dbl(list(x, lb, ub), constrain) 2791.116 2895.2355 3544.3873 2969.4250 3363.5785 39495.546   100\n             constrain_vec(x, lb, ub)  117.096  130.9335  174.7879  150.9415  167.8130  2280.912   100\n            constrain_vec2(x, lb, ub)  154.406  171.3390  221.2204  186.7550  204.7745  2422.075   100\n```\n\n\n:::\n:::\n\n\nYes, the vectorized version is much faster. But it's not as readable as the first one. The dplyr version is cleanest and just as fast.\n\nWhat about if the bounds were fixed?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(\n  (function(x) x)(x),\n  pmap_dbl(list(x, -Inf, Inf), constrain),\n  constrain_vec2(x, -Inf, Inf),\n  times = 100,\n  check = \"equivalent\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: nanoseconds\n                                    expr     min      lq       mean  median      uq     max neval\n                      (function(x) x)(x)     123     123     228.37     164     246    1230   100\n pmap_dbl(list(x, -Inf, Inf), constrain) 2277919 2351780 2526444.60 2455244 2530848 3705580   100\n            constrain_vec2(x, -Inf, Inf)     369     451     653.95     533     779    1722   100\n```\n\n\n:::\n:::\n\n\n## A better version of optim\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"R/utils.R\")\nfn <- function(par, x) {\n  tryCatch(\n    {\n      -sum(bmm::dmixture2p(x, mu = 0, kappa = par[1], pMem = par[2], log = TRUE))\n    },\n    error = function(e) NA\n  )\n}\nx <- bmm::rmixture2p(100)\n\nmicrobenchmark(\n  optim(c(5, 0.1), fn, x = x),\n  optim2(c(5, 0.1), fn, x = x, lower = c(0, 0), upper = c(Inf, 1)),\n  times = 100\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n                                                                  expr      min       lq      mean   median        uq\n                                           optim(c(5, 0.1), fn, x = x)  677.566  709.095  796.1236  723.035  744.9085\n optim2(c(5, 0.1), fn, x = x, lower = c(0, 0), upper = c(Inf,      1)) 6476.647 6579.639 7043.8644 6668.219 6847.7995\n       max neval\n  3858.715   100\n 12019.314   100\n```\n\n\n:::\n:::\n\n\nHow well does it work for different starting values?\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptim3 <- function(par, fn, ...) {\n  fn2 <- function(par, ...) {\n    par <- c(exp(par[1]), inv_logit(par[2]))\n    fn(par, ...)\n  }\n\n  start <- c(log(par[1]), logit(par[2]))\n  res <- optim(start, fn2, ..., control = list(parscale = c(1, 0.1)))\n  c(exp(res$par[1]), inv_logit(res$par[2]))\n}\n\nset.seed(123)\nx <- bmm::rmixture2p(100)\nstart <- as.matrix(expand.grid(\n  kappa = c(1, 5, 10),\n  pMem = c(0.6, 0.9, 0.99)\n))\n\nres <- apply(start, 1, optim3, fn = fn, x = x)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]      [,2]      [,3]     [,4]      [,5]      [,6]      [,7]      [,8]      [,9]\nkappa 4.7261620 4.7263468 4.7270363 4.725718 4.7286134 4.7273205 4.7257450 4.7265932 4.7260440\npMem  0.6122896 0.6123198 0.6122103 0.612269 0.6122014 0.6122376 0.6122722 0.6123254 0.6123247\n```\n\n\n:::\n\n```{.r .cell-code}\nmixtur::fit_mixtur(data.frame(response = x, target = 0, id = 1), model = \"2_component\", unit = \"radians\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nModel fit running. Please wait...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nModel fit finished.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id kappa   p_t   p_u\n1  1 4.726 0.612 0.388\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(\n  apply(start, 1, optim3, fn = fn, x = x),\n  apply(start, 1, optim2, fn = fn, x = x, lower = c(0, 0), upper = c(Inf, 1)),\n  times = 100\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n                                                                             expr      min       lq     mean   median\n                                          apply(start, 1, optim3, fn = fn, x = x) 13.21569 13.59095 14.25060 13.80671\n apply(start, 1, optim2, fn = fn, x = x, lower = c(0, 0), upper = c(Inf,      1)) 71.69621 73.87384 76.07425 75.78614\n       uq      max neval\n 14.11398 20.15654   100\n 77.07342 85.47664   100\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}