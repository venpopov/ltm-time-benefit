{
  "hash": "604798265a15294e89d7148be1815cbb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Playground 1: Optim stuff\"\nformat: html\n---\n\n\n\n\n## Embed a chunk from another notebook\n\n\n\n\n{{< embed model_sqrt.qmd#fit_sqrt >}}\n\n\n\n\n\n\n\n## Contraint/Unconstrain vectorizing tests\n\nI want to build a constrain/unconstrain function. Here' are two versions. The second one is vectorized\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"R/utils.R\")\n\nconstrain <- function(x, lb, ub) {\n  if (is.infinite(lb) && is.infinite(ub)) {\n    x\n  } else if (is.infinite(ub)) {\n    exp(x) + lb\n  } else if (is.infinite(lb)) {\n    ub - exp(x)\n  } else {\n    inv_logit(x, lb = lb, ub = ub)\n  }\n}\n\nconstrain_vec <- function(x, lb, ub) {\n  ifelse(is.infinite(lb) & is.infinite(ub), x,\n    ifelse(is.infinite(ub), exp(x) + lb,\n      ifelse(is.infinite(lb), ub - exp(x),\n        inv_logit(x, lb = lb, ub = ub)\n      )\n    )\n  )\n}\n\nconstrain_vec2 <- function(x, lb, ub) {\n  if (length(lb) == 1 && length(ub) == 1 && is.infinite(lb) && is.infinite(ub)) {\n    return(x)\n  }\n\n  dplyr::case_when(\n    is.infinite(lb) & is.infinite(ub) ~ x,\n    is.infinite(ub) ~ exp(x) + lb,\n    is.infinite(lb) ~ ub - exp(x),\n    .default = inv_logit(x, lb = lb, ub = ub)\n  )\n}\n```\n:::\n\n\n\n\nLet's test them\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nlibrary(microbenchmark)\nN <- 1000\nx <- c(log(rexp(N)), logit(runif(N)), rnorm(N))\nlb <- c(rep(0, N), rep(0, N), rep(-Inf, N))\nub <- c(rep(Inf, N), rep(1, N), rep(Inf, N))\n\nmicrobenchmark(\n  pmap_dbl(list(x, lb, ub), constrain),\n  constrain_vec(x, lb, ub),\n  constrain_vec2(x, lb, ub),\n  times = 100,\n  check = \"equivalent\"\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in microbenchmark(pmap_dbl(list(x, lb, ub), constrain), constrain_vec(x, : less accurate nanosecond times to\navoid potential integer overflows\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n                                 expr      min        lq      mean    median        uq      max neval\n pmap_dbl(list(x, lb, ub), constrain) 2660.777 2708.2755 2882.3939 2735.9505 2794.5600 6758.809   100\n             constrain_vec(x, lb, ub)  116.276  118.9205  145.8936  120.4785  129.9905 1911.092   100\n            constrain_vec2(x, lb, ub)  149.855  154.1805  181.5259  157.2760  165.2300 2173.738   100\n```\n\n\n:::\n:::\n\n\n\n\nYes, the vectorized version is much faster. But it's not as readable as the first one. The dplyr version is cleanest and just as fast.\n\nWhat about if the bounds were fixed?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(\n  (function(x) x)(x),\n  pmap_dbl(list(x, -Inf, Inf), constrain),\n  constrain_vec2(x, -Inf, Inf),\n  times = 100,\n  check = \"equivalent\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: nanoseconds\n                                    expr     min      lq      mean  median      uq     max neval\n                      (function(x) x)(x)      82     123     155.8     123     164     738   100\n pmap_dbl(list(x, -Inf, Inf), constrain) 2183455 2219350 2333747.1 2245406 2293314 3556504   100\n            constrain_vec2(x, -Inf, Inf)     410     451     594.5     615     656    1558   100\n```\n\n\n:::\n:::\n\n\n\n\n## A better version of optim\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"R/utils.R\")\nfn <- function(par, x) {\n  tryCatch(\n    {\n      -sum(bmm::dmixture2p(x, mu = 0, kappa = par[1], pMem = par[2], log = TRUE))\n    },\n    error = function(e) NA\n  )\n}\nx <- bmm::rmixture2p(100)\n\nmicrobenchmark(\n  optim(c(5, 0.1), fn, x = x),\n  optim2(c(5, 0.1), fn, x = x, lower = c(0, 0), upper = c(Inf, 1)),\n  times = 100\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n                                                                  expr      min        lq      mean   median       uq\n                                           optim(c(5, 0.1), fn, x = x)  670.596  687.3855  733.2112  699.911  729.103\n optim2(c(5, 0.1), fn, x = x, lower = c(0, 0), upper = c(Inf,      1)) 5914.414 6004.6550 6371.1249 6071.772 6285.485\n       max neval\n  2290.465   100\n 10633.637   100\n```\n\n\n:::\n:::\n\n\n\n\nHow well does it work for different starting values?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptim3 <- function(par, fn, ...) {\n  fn2 <- function(par, ...) {\n    par <- c(exp(par[1]), inv_logit(par[2]))\n    fn(par, ...)\n  }\n\n  start <- c(log(par[1]), logit(par[2]))\n  res <- optim(start, fn2, ..., control = list(parscale = c(1, 0.1)))\n  c(exp(res$par[1]), inv_logit(res$par[2]))\n}\n\nset.seed(123)\nx <- bmm::rmixture2p(100)\nstart <- as.matrix(expand.grid(\n  kappa = c(1, 5, 10),\n  pMem = c(0.6, 0.9, 0.99)\n))\n\nres <- apply(start, 1, optim3, fn = fn, x = x)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]      [,2]      [,3]     [,4]      [,5]      [,6]      [,7]      [,8]      [,9]\nkappa 4.7261620 4.7263468 4.7270363 4.725718 4.7286134 4.7273205 4.7257450 4.7265932 4.7260440\npMem  0.6122896 0.6123198 0.6122103 0.612269 0.6122014 0.6122376 0.6122722 0.6123254 0.6123247\n```\n\n\n:::\n\n```{.r .cell-code}\nmixtur::fit_mixtur(data.frame(response = x, target = 0, id = 1), model = \"2_component\", unit = \"radians\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nModel fit running. Please wait...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nModel fit finished.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id kappa   p_t   p_u\n1  1 4.726 0.612 0.388\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(\n  apply(start, 1, optim3, fn = fn, x = x),\n  apply(start, 1, optim2, fn = fn, x = x, lower = c(0, 0), upper = c(Inf, 1)),\n  times = 100\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n                                                                             expr      min       lq     mean   median\n                                          apply(start, 1, optim3, fn = fn, x = x) 12.57700 12.74460 13.43638 13.00477\n apply(start, 1, optim2, fn = fn, x = x, lower = c(0, 0), upper = c(Inf,      1)) 69.40168 72.31477 74.84556 73.47360\n       uq       max neval\n 13.38847  20.36634   100\n 74.62646 209.33829   100\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}