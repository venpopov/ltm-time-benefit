{
  "hash": "bd3652d52b770e5e73d52bc44f0eb5c2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Playground 1: Optim stuff\"\nformat: html\n---\n\n\n## Contraint/Unconstrain vectorizing tests\n\nI want to build a constrain/unconstrain function. Here' are two versions. The second one is vectorized\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"R/utils.R\")\n\nconstrain <- function(x, lb, ub) {\n  if (is.infinite(lb) && is.infinite(ub)) {\n    x\n  } else if (is.infinite(ub)) {\n    exp(x) + lb\n  } else if (is.infinite(lb)) {\n    ub - exp(x)\n  } else {\n    inv_logit(x, lb = lb, ub = ub)\n  }\n}\n\nconstrain_vec <- function(x, lb, ub) {\n  ifelse(is.infinite(lb) & is.infinite(ub), x,\n    ifelse(is.infinite(ub), exp(x) + lb,\n      ifelse(is.infinite(lb), ub - exp(x),\n        inv_logit(x, lb = lb, ub = ub)\n      )\n    )\n  )\n}\n\nconstrain_vec2 <- function(x, lb, ub) {\n  if (length(lb) == 1 && length(ub) == 1 && is.infinite(lb) && is.infinite(ub)) {\n    return(x)\n  }\n\n  dplyr::case_when(\n    is.infinite(lb) & is.infinite(ub) ~ x,\n    is.infinite(ub) ~ exp(x) + lb,\n    is.infinite(lb) ~ ub - exp(x),\n    .default = inv_logit(x, lb = lb, ub = ub)\n  )\n}\n```\n:::\n\n\nLet's test them\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nlibrary(microbenchmark)\nN <- 1000\nx <- c(log(rexp(N)), logit(runif(N)), rnorm(N))\nlb <- c(rep(0, N), rep(0, N), rep(-Inf, N))\nub <- c(rep(Inf, N), rep(1, N), rep(Inf, N))\n\nmicrobenchmark(\n  pmap_dbl(list(x, lb, ub), constrain),\n  constrain_vec(x, lb, ub),\n  constrain_vec2(x, lb, ub),\n  times = 100,\n  check = \"equivalent\"\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in microbenchmark(pmap_dbl(list(x, lb, ub), constrain), constrain_vec(x, : less accurate nanosecond times to\navoid potential integer overflows\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n                                 expr      min        lq      mean    median       uq      max neval\n pmap_dbl(list(x, lb, ub), constrain) 2811.903 2923.2590 3195.1485 3017.9075 3150.091 5383.997   100\n             constrain_vec(x, lb, ub)  119.802  124.3325  165.7605  136.2430  159.654 2125.604   100\n            constrain_vec2(x, lb, ub)  154.406  174.2295  236.5261  188.9895  211.519 2426.462   100\n```\n\n\n:::\n:::\n\n\nYes, the vectorized version is much faster. But it's not as readable as the first one. The dplyr version is cleanest and just as fast.\n\nWhat about if the bounds were fixed?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark(\n  (function(x) x)(x),\n  pmap_dbl(list(x, -Inf, Inf), constrain),\n  constrain_vec2(x, -Inf, Inf),\n  times = 100,\n  check = \"equivalent\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: nanoseconds\n                                    expr     min      lq       mean    median      uq     max neval\n                      (function(x) x)(x)      82     123     350.55     164.0     369    7503   100\n pmap_dbl(list(x, -Inf, Inf), constrain) 2319247 2415105 2582184.10 2456986.5 2567830 3874623   100\n            constrain_vec2(x, -Inf, Inf)     369     451     783.10     594.5     984    3116   100\n```\n\n\n:::\n:::\n\n\n## A better version of optim\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"R/utils.R\")\nfn <- function(par, x) {\n  tryCatch(\n    {\n      -sum(bmm::dmixture2p(x, mu = 0, kappa = par[1], pMem = par[2], log = TRUE))\n    },\n    error = function(e) NA\n  )\n}\nx <- bmm::rmixture2p(100)\n\nmicrobenchmark(\n  optim(c(5, 0.1), fn, x = x),\n  optim2(c(5, 0.1), fn, x = x, lower = c(0, 0), upper = c(Inf, 1)),\n  times = 100\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: microseconds\n                                                                  expr      min        lq      mean    median       uq\n                                           optim(c(5, 0.1), fn, x = x)  632.671  666.1885  768.5782  703.2935  743.371\n optim2(c(5, 0.1), fn, x = x, lower = c(0, 0), upper = c(Inf,      1)) 6555.736 6794.9505 7308.1221 6986.8510 7400.807\n       max neval\n  3834.279   100\n 11758.267   100\n```\n\n\n:::\n:::\n\n\nHow well does it work for different starting values?\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptim3 <- function(par, fn, ...) {\n  fn2 <- function(par, ...) {\n    par <- c(exp(par[1]), inv_logit(par[2]))\n    fn(par, ...)\n  }\n\n  start <- c(log(par[1]), logit(par[2]))\n  res <- optim(start, fn2, ..., control = list(parscale = c(1, 0.1)))\n  c(exp(res$par[1]), inv_logit(res$par[2]))\n}\n\nset.seed(123)\nx <- bmm::rmixture2p(100)\nstart <- as.matrix(expand.grid(\n  kappa = c(1, 5, 10),\n  pMem = c(0.6, 0.9, 0.99)\n))\n\nres <- apply(start, 1, optim3, fn = fn, x = x)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]      [,2]      [,3]     [,4]      [,5]      [,6]      [,7]      [,8]      [,9]\nkappa 4.7261620 4.7263468 4.7270363 4.725718 4.7286134 4.7273205 4.7257450 4.7265932 4.7260440\npMem  0.6122896 0.6123198 0.6122103 0.612269 0.6122014 0.6122376 0.6122722 0.6123254 0.6123247\n```\n\n\n:::\n\n```{.r .cell-code}\nmixtur::fit_mixtur(data.frame(response = x, target = 0, id = 1), model = \"2_component\", unit = \"radians\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nModel fit running. Please wait...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nModel fit finished.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id kappa   p_t   p_u\n1  1 4.726 0.612 0.388\n```\n\n\n:::\n\n```{.r .cell-code}\nmicrobenchmark(\n  apply(start, 1, optim3, fn = fn, x = x),\n  apply(start, 1, optim2, fn = fn, x = x, lower = c(0, 0), upper = c(Inf, 1)),\n  times = 100\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUnit: milliseconds\n                                                                             expr      min       lq     mean   median\n                                          apply(start, 1, optim3, fn = fn, x = x) 13.59798 14.06780 14.78477 14.28514\n apply(start, 1, optim2, fn = fn, x = x, lower = c(0, 0), upper = c(Inf,      1)) 72.94609 76.93465 80.14172 78.92127\n       uq       max neval\n 14.87449  21.12189   100\n 81.38789 182.95069   100\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}