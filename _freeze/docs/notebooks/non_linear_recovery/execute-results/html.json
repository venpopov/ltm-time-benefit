{
  "hash": "5b09b593a7f11b8964b495d6a6ca264e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Explore model predictions\"\nformat: html\ndate: 05/20/2024\ndate-modified: last-modified\nfilters:\n  - shinylive\n---\n\n\n\n\n## Non-linear resource recovery model\n\nIn [Exploring model predictions](model-explore.qmd) I used a shiny app to understand how the basic model with linear resource recovery works, and I found that it does not predict an interaction between chunking and free time proactive benefits. I suspect that a model with a non-linear recovery will be different, because for a fixed time interval it will recover more resource the lower the resource level is. Let's explore this. Resources are recovered according to the following equation:\n\n$$\nR(t) = R_{\\text{current}} + (R_{\\text{max}} - R_{\\text{current}})(1 - e^{-\\text{rate} \\times t})\n$$\n\nwhere $R_{\\text{max}}$ is the maximum resource level, $R_{\\text{current}}$ is the current resource level, $\\text{rate}$ is the recovery rate, and $t$ is the time elapsed.\n\n## Just the resource recovery\n\nPlot the amount of resource recovered for a fixed time interval as a function of the current resource level. \n\nHere's a fixed plot for rate = 0.5:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresources <- function(R, rate, time, r_max = 1) {\n  (r_max - R) * (1 - exp(-rate * time))\n}\npars <- expand.grid(R = seq(0, 0.9, by = 0.1), time = seq(0, 6, by = 0.1))\npars$resources <- resources(pars$R, 0.5, pars$time)\n\n# ggplot with rate as frame and then convert via ggplotly to an interactive plot\nlibrary(ggplot2)\nggplot(pars, aes(time, resources + R, color = R, group = R)) +\n  geom_line() +\n  theme_test(base_size = 14) +\n  labs(\n    title = \"Resource recovery\",\n    x = \"Elapse time for recovery\",\n    y = \"Available resources\",\n    color = \"Initial resource level\"\n  )\n```\n\n::: {.cell-output-display}\n![](non_linear_recovery_files/figure-html/resource-recovery-fixed-1.png){width=672}\n:::\n:::\n\n\n\n\n<br>\n\nYes, now we can clearly see above that within the same time interval, the lower the resource level, the more resources are recovered. Let's see if this produces the interaction we expected.\n\n## Model predictions\n\n::: {.column-page-right}\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 700\nlibrary(shiny)\nlibrary(shinylive)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\n\n# define functions\npred_prob <- function(\n    setsize, ISI = rep(0.5, setsize), item_in_ltm = rep(TRUE, setsize),\n    prop = 0.2, prop_ltm = 0.5, tau = 0.15, gain = 25, rate = 0.1,\n    r_max = 1, lambda = 1, growth = \"linear\", type = \"response\") {\n  R <- r_max\n  strengths <- vector(\"numeric\", length = setsize)\n  p_recall <- vector(\"numeric\", length = setsize)\n  prop_ltm <- ifelse(item_in_ltm, prop_ltm, 1)\n\n  for (item in 1:setsize) {\n    # strength of the item and recall probability\n    strengths[item] <- (prop * R)^lambda\n\n    # amount of resources consumed by the item\n    r_cost <- strengths[item]^(1 / lambda) * prop_ltm[item]\n    R <- R - r_cost\n\n    # recover resources\n    R <- switch(growth,\n      \"linear\" = min(r_max, R + rate * ISI[item]),\n      \"asy\" = R + (r_max - R) * (1 - exp(-rate * ISI[item]))\n    )\n  }\n\n  if (type == \"response\") {\n    1 / (1 + exp(-(strengths - tau) * gain))\n  } else {\n    strengths\n  }\n}\n\npredict_resmodel <- function(object, data, group_by, type = \"response\", ...) {\n  if (missing(group_by)) {\n    pred <- pred_prob(\n      setsize = nrow(data),\n      ISI = data$ISI,\n      item_in_ltm = data$item_in_ltm,\n      prop = object[\"prop\"],\n      prop_ltm = object[\"prop_ltm\"],\n      tau = object[\"tau\"],\n      gain = object[\"gain\"],\n      rate = object[\"rate\"],\n      type = type,\n      ...\n    )\n    return(pred)\n  }\n\n  by <- do.call(paste, c(data[, group_by], sep = \"_\"))\n  out <- lapply(split(data, by), function(x) {\n    x$pred_tmp_col295 <- predict_resmodel(object, x, type = type, ...)\n    x\n  })\n  out <- do.call(rbind, out)\n  out <- suppressMessages(dplyr::left_join(data, out))\n  out$pred_tmp_col295\n}\n\ndata <- expand.grid(\n  chunk = c(\"known\", \"random\"),\n  gap = seq(500, 6000, by = 225),\n  itemtype = c(\"SP1-3\", \"SP4-6\", \"SP7-9\")\n)\n\ndata$ISI <- ifelse(data$itemtype == \"SP1-3\", data$gap / 1000, 0.5)\ndata$item_in_ltm <- ifelse(data$itemtype == \"SP1-3\", data$chunk == \"known\", FALSE)\nshinyApp(\n  ui = fluidPage(\n    titlePanel(\"Interactive Plot\"),\n    sidebarLayout(\n      sidebarPanel(\n        sliderInput(\"prop\", \"prop:\", min = 0, max = 1, value = 0.15),\n        sliderInput(\"prop_ltm\", \"prop_ltm:\", min = 0, max = 1, value = 0.5),\n        sliderInput(\"rate\", \"rate:\", min = 0, max = 1, value = 0.25),\n        sliderInput(\"gain\", \"gain:\", min = 1, max = 100, value = 33),\n        sliderInput(\"tau\", \"tau:\", min = 0, max = 1, value = 0.12),\n      ),\n      mainPanel(\n        plotOutput(\"distPlot\")\n      )\n    )\n  ),\n  server = function(input, output) {\n    output$distPlot <- renderPlot({\n      par <- c(prop = input$prop, prop_ltm = input$prop_ltm, rate = input$rate, gain = input$gain, tau = input$tau)\n      data |>\n        mutate(\n          Probability = predict_resmodel(par, data = data, group_by = c(\"gap\", \"chunk\"), growth = \"asy\", lambda = 1),\n          Strength = predict_resmodel(par, data = data, group_by = c(\"gap\", \"chunk\"), type = \"strength\", growth = \"asy\", lambda = 1)\n        ) |>\n        pivot_longer(c(Probability, Strength), names_to = \"type\", values_to = \"value\") |>\n        ggplot(aes(gap, value, color = chunk, group = chunk)) +\n        geom_line() +\n        scale_color_discrete(\"1st chunk LTM?\") +\n        facet_grid(type ~ itemtype, scales = \"free\") +\n        theme_classic(base_size = 14)\n    })\n  }\n)\n```\n\n:::\n\n\nWith the non-linear resource recovery, we do predict an interaction between chunking and free time proactive benefits. In contrast to the linear recovery model, this interaction occurs for a large range of parameter values and does not require that resources are depleted completely in one condition in order for the interaction to occur.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}